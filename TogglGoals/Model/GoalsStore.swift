//
//  GoalsStore.swift
//  TogglGoals
//
//  Created by David Davila on 01.02.17.
//  Copyright Â© 2017 davi. All rights reserved.
//

import Foundation
import SQLite
import Result
import ReactiveSwift

typealias ProjectIndexedGoals = [ProjectID : Goal]

/// Read the goal of value associated with the provided project ID and return a `Property`
/// representing the value of the goal over time.
///
/// - note: `nil` represents a goal that does not exist yet or that has been deleted.
typealias ReadGoalAction = Action<ProjectID, Property<Goal?>, NoError>

/// Update the value the goal associated to the project ID matching the provided goal's
/// `projectId` property. Returns a producer that completes immediately.
typealias WriteGoalAction = Action<Goal, Void, NoError>

/// Delete the goal associated to the provided project ID. Returns a producer that
/// completes immediately.
typealias DeleteGoalAction = Action<ProjectID, Void, NoError>

/// Action which returns a producer that emits a stream of updates, starting with a full value
/// and followed by full or incremental updates, corresponding to a `ProjectIDsByGoals` value.
typealias FetchProjectIDsByGoalsAction = Action<Void, ProjectIDsByGoals.Update, NoError>

/// An entity that stores and retrieves Goal values
protocol GoalsStore {
    /// Action which takes a project ID as input and returns a producer that emits a single
    /// Property value corresponding to the goal associated with that project ID.
    var readGoalAction: ReadGoalAction { get }

    /// Action which accepts new (or edited) goal values and stores them.
    var writeGoalAction: WriteGoalAction { get }

    /// Action which takes a project ID as input and deletes the goal associated with that project ID.
    var deleteGoalAction: DeleteGoalAction { get }
}

/// An entity that receives a stream of collections of project IDs and produces a stream of
/// `ProjectIDsByGoals` values and incremental updates generated by matching the received project IDs
/// against the goals and changes to the goals it has knowledge of.
protocol ProjectIDsByGoalsProducing {
    /// Target that accepts and array of unsorted project IDs that will be matched against the goals
    /// that this store has knowledge of.
    var projectIDs: BindingTarget<[ProjectID]> { get }

    /// Action which returns a producer that emits a stream of updates, starting with a full value
    /// and followed by full or incremental updates, corresponding to the `ProjectIDsByGoals` generated by
    /// matching project IDs provided to the `projectIDs` target against the goals this store knows about.
    var fetchProjectIDsByGoalsAction: FetchProjectIDsByGoalsAction { get }
}

/// Represents an entity that conforms to both the `GoalsStore` and `ProjectIDsByGoalsProducing` protocols.
protocol ProjectIDsByGoalsProducingGoalsStore: GoalsStore, ProjectIDsByGoalsProducing { }

class SQLiteGoalsStore: ProjectIDsByGoalsProducingGoalsStore {
    /// The database connection used to store and retrieve goals.
    private let db: Connection

    // MARK: - Table and expression entities

    private let goalsTable = Table("time_goal")
    private let idExpression = Expression<Int64>("id")
    private let projectIdExpression = Expression<ProjectID>("project_id")
    private let hoursPerMonthExpression = Expression<Int>("hours_per_month")
    private let workWeekdaysExpression = Expression<WeekdaySelection>("work_weekdays")

    private let (lifetime, token) = Lifetime.make()
    private lazy var scheduler = QueueScheduler()

    /// Initialize an instance that will read and write its database in the provided base directory.
    /// If no database file exists under the provided directory it will create one.
    /// Returns `nil` if the database file cannot be open and cannot be created.
    ///
    /// - parameters:
    ///   - baseDirectory: The `URL` of the directory from which to read and to which to write
    ///     the database used by this instance.
    init?(baseDirectory: URL?) {
        do {
            let databaseURL = URL(fileURLWithPath: "goalsdb.sqlite3", relativeTo: baseDirectory)
            db = try Connection(databaseURL.absoluteString)
        } catch {
            return nil
        }
        _ = storedGoalUpdates // nudge it

        ensureSchemaCreated()
        connectInputsToAllGoals()
        connectInputsToMGActionState()
        retrieveAllGoals()
    }

    // MARK: - Public actions

    /// Action which takes a project ID as input and returns a producer that emits a single
    /// Property value corresponding to the goal associated with that project ID.
    lazy var readGoalAction = ReadGoalAction { [unowned self] projectId in
        let goalProperty = self.allGoals.map { $0?[projectId] }.skipRepeats { $0 == $1 }
        return SignalProducer(value: goalProperty)
    }

    /// Action which accepts new (or edited) goal values and stores them.
    lazy var writeGoalAction = WriteGoalAction(enabledIf: modifyGoalAction.isEnabled) {
        [modifyGoalAction] goal in
        _ = modifyGoalAction.applySerially((goal, goal.projectId)).start()
        return SignalProducer.empty
    }

    /// Action which takes a project ID as input and deletes the goal associated with that project ID.
    lazy var deleteGoalAction = DeleteGoalAction(enabledIf: modifyGoalAction.isEnabled) {
        [modifyGoalAction] projectId in
        _ = modifyGoalAction.applySerially((nil, projectId)).start()
        return SignalProducer.empty
    }


    // MARK: - Generation of ProjectIDsByGoals

    /// Target that accepts and array of unsorted project IDs that will be matched against the goals
    /// that this store has knowledge of.
    var projectIDs: BindingTarget<[ProjectID]> { return _projectIDs.deoptionalizedBindingTarget }

    /// The value backer for the `projectIDs` target.
    private var _projectIDs = MutableProperty<[ProjectID]?>(nil)

    /// Keeps the values of all goals indexed by project ID.
    private let allGoals = MutableProperty<ProjectIndexedGoals?>(nil)

    /// Connect `modifyGoalAction`'s output to allGoals outside of the lazy initialization process
    /// to avoid a dependency cycle.
    private func connectInputsToAllGoals() {
        allGoals <~ modifyGoalAction.values.map { $0.3 }
    }

    /// Produces a new `ProjectIDsByGoals` value each time a value is sent to the `projectIDs` target
    /// that contains a different set of unique IDs than the last seen one.
    private lazy var fullRefreshUpdateProducer: SignalProducer<ProjectIDsByGoals, NoError> = {
        return _projectIDs.producer.skipNil().combineLatest(with: allGoals.producer.skipNil())
            .skipRepeats { (old, new) -> Bool in // let through only changes in project IDs, order insensitive
                let oldIds = Set(old.0)
                let newIds = Set(new.0)
                return oldIds == newIds
            }
            .map(ProjectIDsByGoals.init)
    }()

    /// The type of the state representing the context for the `modifyGoalAction`.
    private typealias MGActionState = (ProjectIndexedGoals, ProjectIDsByGoals)
    /// The type of the input of the `modifyGoalAction`.
    private typealias MGActionInput = (Goal?, ProjectID)
    /// The type of the output of the `modifyGoalAction`
    private typealias MGActionOutput = (StoredGoalUpdate, ProjectIDsByGoals.Update.GoalUpdate, ProjectIDsByGoals, ProjectIndexedGoals)

    /// Keeps the state representing the context for the `modifyGoalAction`.
    private let mgActionState = MutableProperty<MGActionState?>(nil)

    /// Feed part of `modifyGoalAction`'s output back to its state / context, together with the current
    /// indexed goals, outside of the initialization process to avoid a dependency cycle.
    private func connectInputsToMGActionState() {
        let allGoalsProducer = allGoals.producer.skipNil()
        let projectIDsByGoalsProducer = SignalProducer.merge(fullRefreshUpdateProducer,
                                                             modifyGoalAction.values.producer.map { $0.2 })
        mgActionState <~ allGoalsProducer.combineLatest(with: projectIDsByGoalsProducer)
    }

    /// Action that encloses a single add / update / remove goal operation. Takes a goal or `nil`
    /// and a project ID as its input, and runs in the context determined by the value of `allGoals`
    /// prior to the goal addition, update or removal and the last generated value of `ProjectIDsByGoals`.
    /// It has no side effects nor does it depend on any state other than that enclosed in the
    /// `mgaActionState` property.
    /// Its output is:
    /// * A `StoredGoalUpdate` value to be sent to the `storedGoalUpdates` target that
    ///   will commit the change to the database.
    /// * A `GoalUpdate` that will be sent to any listeners of incremental updates to the
    ///   `ProjectIDsByGoals` value.
    /// * The `ProjectIDsByGoals` value corresponding to applying the update to the previously seen value,
    ///   which will be fed back into the action's state.
    /// * A collection of ProjectID-indexed goals representing the state of the indexed goals after the
    ///   goal addition, update or removal.
    private lazy var modifyGoalAction = Action<MGActionInput, MGActionOutput, NoError>(unwrapping: mgActionState) {
        (state, input) in
        let (currentIndexedGoals, currentIDsByGoals) = state
        let (newGoalOrNil, projectId) = input
        let oldGoal = currentIndexedGoals[projectId]

        let newIndexedGoals: ProjectIndexedGoals = {
            var t = currentIndexedGoals
            t[projectId] = newGoalOrNil
            return t
        }()

        let idsByGoalsUpdate = ProjectIDsByGoals.Update.GoalUpdate.forGoalChange(affecting: currentIDsByGoals,
                                                                                 for: projectId,
                                                                                 from: oldGoal,
                                                                                 producing: newIndexedGoals)!
        let persistedGoalUpdate: StoredGoalUpdate = { [goal = newGoalOrNil] in
            switch (idsByGoalsUpdate) {
            case .create: return .create(goal!)
            case .update: return .update(goal!)
            case .remove: return .delete(projectId)
            }
        }()

        let output = (persistedGoalUpdate, idsByGoalsUpdate, idsByGoalsUpdate.apply(to: currentIDsByGoals), newIndexedGoals)
        return SignalProducer(value: output)
    }

    /// Action which returns a producer that emits a stream of updates, starting with a full value
    /// and followed by full or incremental updates, corresponding to the ProjectIDsByGoals generated by
    /// matching project IDs provided to the `projectIDs` target against the goals this store knows about.
    lazy var fetchProjectIDsByGoalsAction = Action<(), ProjectIDsByGoals.Update, NoError> { [unowned self] in
        return SignalProducer.merge(self.fullRefreshUpdateProducer.map { ProjectIDsByGoals.Update.full($0) },
                                    self.modifyGoalAction.values.producer.map { ProjectIDsByGoals.Update.singleGoal($0.1) })
    }

    
    // MARK: -

    /// Represents an update to a stored goal.
    private enum StoredGoalUpdate {
        /// The creation of a goal. Encloses the created goal.
        case create(Goal)
        /// The modification of an existing goal.
        /// The enclosed goal represents the new value.
        case update(Goal)
        /// The deletion of the goal associated with the enclosed project ID.
        case delete(ProjectID)
    }

    /// Accepts goal updates outputted from the `modifyGoalAction` and persists the changes
    /// in the database.
    private lazy var storedGoalUpdates: BindingTarget<StoredGoalUpdate> = {
        let target = BindingTarget<StoredGoalUpdate>(on: scheduler, lifetime: lifetime) {
            [unowned self] update in
            switch update {
            case .create(let goal):
                self.storeGoal(goal)
            case .update(let goal):
                self.storeGoal(goal)
            case .delete(let projectId):
                self.deleteGoal(for: projectId)
            }
        }
        target <~ modifyGoalAction.values.map { $0.0 }
        return target
    }()

    /// Stores the provided goal into the database synchronously.
    private func storeGoal(_ goal: Goal) {
        try! db.run(goalsTable.insert(or: .replace,
                                      projectIdExpression <- goal.projectId,
                                      hoursPerMonthExpression <- goal.hoursPerMonth,
                                      workWeekdaysExpression <- goal.workWeekdays))
        // TODO: synchronize periodically instead of writing immediately
    }

    /// Deletes synchronously from the database the goal corresponding to the
    /// provided project ID.
    private func deleteGoal(for projectId: ProjectID) {
        let q = goalsTable.filter(projectIdExpression == projectId)
        try! db.run(q.delete())
    }

    /// Creates the underlying database schema if not already created.
    private func ensureSchemaCreated() {
        try! db.run(goalsTable.create(ifNotExists: true) { t in
            t.column(idExpression, primaryKey: .autoincrement)
            t.column(projectIdExpression, unique: true)
            t.column(hoursPerMonthExpression)
            t.column(workWeekdaysExpression)
        })
    }

    /// Retrieves all goals from the database and stores then in the value of the `allGoals` property.
    private func retrieveAllGoals() {
        var retrievedGoals = ProjectIndexedGoals()
        let retrievedRows = try! db.prepare(goalsTable)
        for retrievedRow in retrievedRows {
            let projectIdValue = retrievedRow[projectIdExpression]
            let hoursPerMonthValue = retrievedRow[hoursPerMonthExpression]
            let workWeekdaysValue = try! /* TODO */ retrievedRow.get(workWeekdaysExpression) // [1]
            let goal = Goal(forProjectId: projectIdValue,
                            hoursPerMonth: hoursPerMonthValue,
                            workWeekdays: workWeekdaysValue)
            retrievedGoals[projectIdValue] = goal
        }

        allGoals <~ SignalProducer(value: retrievedGoals)

        // [1] Can't use subscripts with custom types.
        // https://github.com/stephencelis/SQLite.swift/blob/master/Documentation/Index.md#custom-type-caveats
        // (f3da195)
    }
}

extension WeekdaySelection: Value {
    typealias Datatype = Int64

    static var declaredDatatype: String {
        get {
            return Int64.declaredDatatype
        }
    }

    static func fromDatatypeValue(_ datatypeValue: Datatype) -> WeekdaySelection {
        return WeekdaySelection(integerRepresentation: IntegerRepresentationType(datatypeValue))
    }

    var datatypeValue: Datatype {
        get {
            return Datatype(integerRepresentation)
        }
    }
}
