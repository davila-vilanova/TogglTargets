//
//  TimeTargetsStore.swift
//  TogglTargets
//
//  Created by David Davila on 01.02.17.
//  Copyright Â© 2017 davi. All rights reserved.
//

import Foundation
import SQLite
import Result
import ReactiveSwift

typealias ProjectIdIndexedTimeTargets = [ProjectID: TimeTarget]

/// Producer of `ProjectIDsByTimeTargets.Update` values that when started emits a
// `full(ProjectIDsByTimeTargets)` value which can be followed by full or
/// incremental updates.
typealias ProjectIDsByTimeTargetsProducer = SignalProducer<ProjectIDsByTimeTargets.Update, NoError>

/// An entity that stores and retrieves TimeTarget values
protocol TimeTargetsStore {

    /// Function which takes a project ID as input and returns a producer that
    /// emits values over time corresponding to the time target associated with that
    /// project ID.
    ///
    /// - note: `nil` target values represent a time target that does not exist yet or
    ///         that has been deleted.
    var readTimeTarget: ReadTimeTarget { get }

    /// Target which accepts new (or edited) timeTarget values.
    var writeTimeTarget: BindingTarget<TimeTarget> { get }

    /// Target which for each received project ID deletes the timeTarget associated with that project ID.
    var deleteTimeTarget: BindingTarget<ProjectID> { get }
}

/// An entity that receives a stream of collections of project IDs and produces a stream of
/// `ProjectIDsByTimeTargets` values and incremental updates generated by matching the received project IDs
/// against the time targets and changes to the time targets it has knowledge of.
protocol ProjectIDsByTimeTargetsProducing {
    /// Target that accepts and array of unsorted project IDs that will be matched against the time targets
    /// that this store has knowledge of.
    var projectIDs: BindingTarget<[ProjectID]> { get }

    /// Producer of `ProjectIDsByTimeTargets.Update` values that when started emits a
    // `full(ProjectIDsByTimeTargets)` value which can be followed by full or
    /// incremental updates, corresponding to the `ProjectIDsByTimeTargets` generated
    /// by matching project IDs provided to the `projectIDs` target against the
    /// time targets this store knows about.
    var projectIDsByTimeTargetsProducer: ProjectIDsByTimeTargetsProducer { get }
}

protocol TimeTargetPersistenceProvider {
    var persistTimeTarget: BindingTarget<TimeTarget> { get }
    var deleteTimeTarget: BindingTarget<ProjectID> { get }
    var allTimeTargets: MutableProperty<ProjectIdIndexedTimeTargets> { get }
}

class SQLiteTimeTargetPersistenceProvider: TimeTargetPersistenceProvider {
    /// The database connection used to store and retrieve time targets.
    private let db: Connection

    // MARK: - Table and expression entities

    private let timeTargetsTable = Table("time_target")
    private let idExpression = Expression<Int64>("id")
    private let projectIdExpression = Expression<ProjectID>("project_id")
    private let hoursTargetExpression = Expression<Int>("hours")
    private let workWeekdaysExpression = Expression<WeekdaySelection>("work_weekdays")

    // MARK: -

    private let (lifetime, token) = Lifetime.make()
    private lazy var scheduler = QueueScheduler()

    private let _persistTimeTarget = MutableProperty<TimeTarget?>(nil)

    /// Persists the provided time target into the database synchronously.
    var persistTimeTarget: BindingTarget<TimeTarget> { return _persistTimeTarget.deoptionalizedBindingTarget }

    private let _deleteTimeTarget = MutableProperty<ProjectID?>(nil)

    /// Deletes synchronously from the database the time target corresponding to the
    /// provided project ID.
    var deleteTimeTarget: BindingTarget<ProjectID> { return _deleteTimeTarget.deoptionalizedBindingTarget }

    lazy var allTimeTargets = MutableProperty<ProjectIdIndexedTimeTargets>(retrieveAllTimeTargets())

    /// Retrieves all time targets from the database
    private func retrieveAllTimeTargets() -> ProjectIdIndexedTimeTargets {
        var retrievedTimeTargets = ProjectIdIndexedTimeTargets()
        let retrievedRows = try! db.prepare(timeTargetsTable)
        for retrievedRow in retrievedRows {
            let projectIdValue = retrievedRow[projectIdExpression]
            let hoursTargetValue = retrievedRow[hoursTargetExpression]
            let workWeekdaysValue = try! /* TODO */ retrievedRow.get(workWeekdaysExpression) // [1]
            let timeTarget = TimeTarget(for: projectIdValue,
                            hoursTarget: hoursTargetValue,
                            workWeekdays: workWeekdaysValue)
            retrievedTimeTargets[projectIdValue] = timeTarget
        }

        return retrievedTimeTargets
        // [1] Can't use subscripts with custom types.
        // https://github.com/stephencelis/SQLite.swift/blob/master/Documentation/Index.md#custom-type-caveats
        // (f3da195)
    }

    /// Initialize an instance that will read and write its database in the provided base directory.
    /// If no database file exists under the provided directory it will create one.
    /// Returns `nil` if the database file cannot be opened and cannot be created.
    ///
    /// - parameters:
    ///   - baseDirectory: The `URL` of the directory from which to read and to which to write
    ///     the database used by this instance.
    init?(baseDirectory: URL?) {
        do {
            let databaseURL = URL(fileURLWithPath: "timetargetsdb.sqlite3", relativeTo: baseDirectory)
            db = try Connection(databaseURL.absoluteString)
        } catch {
            return nil
        }

        ensureSchemaCreated()

        let persistProducer = _persistTimeTarget.producer.skipNil().on(value: { [unowned self] timeTarget in
            try! self.db.run(self.timeTargetsTable.insert(or: .replace,
                                                    self.projectIdExpression <- timeTarget.projectId,
                                                    self.hoursTargetExpression <- timeTarget.hoursTarget,
                                                    self.workWeekdaysExpression <- timeTarget.workWeekdays))
            // TODO: synchronize periodically instead of writing immediately
        }).start(on: timeTargetWriteScheduler)

        let deleteProducer = _deleteTimeTarget.producer.skipNil().on(value: { [unowned self] projectId in
            let q = self.timeTargetsTable.filter(self.projectIdExpression == projectId)
            try! self.db.run(q.delete())
        }).start(on: timeTargetWriteScheduler)

        allTimeTargets <~ persistProducer.withLatest(from: allTimeTargets).map {
            $1.updatingValue($0, forKey: $0.projectId)
        }

        allTimeTargets <~ deleteProducer.withLatest(from: allTimeTargets).map {
            $1.updatingValue(nil, forKey: $0)
        }
    }

    /// Creates the underlying database schema if not already created.
    private func ensureSchemaCreated() {
        try! db.run(timeTargetsTable.create(ifNotExists: true) { t in
            t.column(idExpression, primaryKey: .autoincrement)
            t.column(projectIdExpression, unique: true)
            t.column(hoursTargetExpression)
            t.column(workWeekdaysExpression)
        })
    }
}

// MARK: -

/// Represents an entity that conforms to both the `TimeTargetsStore` and `ProjectIDsByTimeTargetsProducing` protocols.
protocol ProjectIDsProducingTimeTargetsStore: TimeTargetsStore, ProjectIDsByTimeTargetsProducing { }

// MARK: -

class ConcreteProjectIDsProducingTimeTargetsStore: ProjectIDsProducingTimeTargetsStore {

    private let (lifetime, token) = Lifetime.make()

    private let persistenceProvider: TimeTargetPersistenceProvider
    private let undoManager: UndoManager

    init(persistenceProvider: TimeTargetPersistenceProvider, undoManager: UndoManager) {
        self.persistenceProvider = persistenceProvider
        self.undoManager = undoManager

        let writeTimeTargetProducer = _writeTimeTarget.producer.skipNil()
        let deleteTimeTargetProducer = _deleteTimeTarget.producer.skipNil()

        let undoModifyOrDeleteTimeTarget =
            BindingTarget<TimeTarget>(on: timeTargetWriteScheduler,
                                      lifetime: lifetime) { [unowned _writeTimeTarget] timeTargetBeforeEditing in
                                        undoManager.registerUndo(withTarget: _writeTimeTarget) {
                                            $0 <~ SignalProducer(value: timeTargetBeforeEditing)
                                                .start(on: UIScheduler())
                                        }
        }
        let undoCreateTimeTarget = BindingTarget<ProjectID>(on: timeTargetWriteScheduler, lifetime: lifetime) { [unowned _deleteTimeTarget] projectId in // swiftlint:disable:this line_length
            undoManager.registerUndo(withTarget: _deleteTimeTarget,
                                     handler: { $0 <~ SignalProducer(value: projectId).start(on: UIScheduler()) })
        }
        let timeTargetsPreModification = writeTimeTargetProducer.map { $0.projectId }
            .withLatest(from: persistenceProvider.allTimeTargets).map { $0.1[$0.0] }.skipNil()
        let timeTargetsPreDeletion = deleteTimeTargetProducer.withLatest(from: persistenceProvider.allTimeTargets)
            .map { $0.1[$0.0] }.skipNil()

        undoModifyOrDeleteTimeTarget <~ SignalProducer.merge(timeTargetsPreModification, timeTargetsPreDeletion)

        let projectIdsOfCreatedTimeTargets = writeTimeTargetProducer.map { $0.projectId }
            .withLatest(from: persistenceProvider.allTimeTargets)
            .map { ($0.1[$0.0], $0.0) }.filter { $0.0 == nil }.map { $0.1 }

        undoCreateTimeTarget <~ projectIdsOfCreatedTimeTargets

        let singleTimeTargetUpdateComputer = Property<SingleTimeTargetUpdateComputer?>(
            initial: nil,
            then: projectIDsByTimeTargetsFullRefresh.withLatest(from: persistenceProvider.allTimeTargets)
                .map { [unowned self] (projectIDsByTimeTargetsState, indexedTimeTargetsState) in
                    SingleTimeTargetUpdateComputer(initialStateIndexedTimeTargets: indexedTimeTargetsState,
                                                   initialStateProjectIDsByTimeTargets: projectIDsByTimeTargetsState,
                                                   inputWriteTimeTarget: writeTimeTargetProducer,
                                                   inputDeleteTimeTarget: deleteTimeTargetProducer,
                                                   outputProjectIDsByTimeTargetsUpdate:
                        self.projectIDsByTimeTargetsLastSingleUpdate.deoptionalizedBindingTarget)
            }
        )

        lifetime.observeEnded {
            _ = singleTimeTargetUpdateComputer
        }

        persistenceProvider.persistTimeTarget <~ writeTimeTargetProducer
        persistenceProvider.deleteTimeTarget <~ deleteTimeTargetProducer
    }

    // MARK: - TimeTarget interface

    /// Function which takes a project ID as input and returns a producer that
    /// emits values over time corresponding to the time target associated with that
    /// project ID.
    ///
    /// - note: `nil` target values represent a time target that does not exist yet or
    ///         that has been deleted.
    lazy var readTimeTarget: ReadTimeTarget = { projectID in
        self.persistenceProvider.allTimeTargets.producer.map { $0[projectID] }.skipRepeats { $0 == $1 }
    }

    var writeTimeTarget: BindingTarget<TimeTarget> { return _writeTimeTarget.deoptionalizedBindingTarget }
    private let _writeTimeTarget = MutableProperty<TimeTarget?>(nil)

    var deleteTimeTarget: BindingTarget<ProjectID> { return _deleteTimeTarget.deoptionalizedBindingTarget }
    private let _deleteTimeTarget = MutableProperty<ProjectID?>(nil)

    // MARK: - Generation of ProjectIDsByTimeTargets

    /// Target that accepts an array of unsorted project IDs that will be matched against the time targets
    /// that this store has knowledge of.
    var projectIDs: BindingTarget<[ProjectID]> { return _projectIDs.deoptionalizedBindingTarget }

    /// The value backer for the `projectIDs` target.
    private var _projectIDs = MutableProperty<[ProjectID]?>(nil)

    /// Produces a new `ProjectIDsByTimeTargets` value each time a value is sent to the `projectIDs` target
    /// that contains a different set of unique IDs than the last seen one.
    private lazy var projectIDsByTimeTargetsFullRefresh: SignalProducer<ProjectIDsByTimeTargets, NoError> =
        _projectIDs.producer.skipNil().withLatest(from: persistenceProvider.allTimeTargets)
            .skipRepeats { (old, new) -> Bool in // let through only changes in project IDs, order insensitive
                let oldIds = Set(old.0)
                let newIds = Set(new.0)
                return oldIds == newIds
            }
            .map(ProjectIDsByTimeTargets.init)

    /// Used to connect the output of the current `SingleTimeTargetUpdateComputer`
    /// to `projectIDsByTimeTargetsProducer`.
    private let projectIDsByTimeTargetsLastSingleUpdate =
        MutableProperty<ProjectIDsByTimeTargets.Update.TimeTargetUpdate?>(nil)

    /// Producer of `ProjectIDsByTimeTargets.Update` values that when started emits a
    // `full(ProjectIDsByTimeTargets)` value which can be followed by by full or
    /// incremental updates, corresponding to the `ProjectIDsByTimeTargets` generated
    /// by matching project IDs provided to the `projectIDs` target against the
    /// time targets this store knows about.
    lazy var projectIDsByTimeTargetsProducer: ProjectIDsByTimeTargetsProducer =
        SignalProducer.merge(
            // Send a full value and any full value updates that happen from now on
            projectIDsByTimeTargetsFullRefresh.map (ProjectIDsByTimeTargets.Update.full),
            // Send any updates to a single time target that happen from now on
            projectIDsByTimeTargetsLastSingleUpdate.producer.skipNil()
                .map (ProjectIDsByTimeTargets.Update.singleTimeTarget)
    )
}

extension WeekdaySelection: Value {
    typealias Datatype = Int64

    static var declaredDatatype: String {
        return Int64.declaredDatatype
    }

    static func fromDatatypeValue(_ datatypeValue: Datatype) -> WeekdaySelection {
        return WeekdaySelection(integerRepresentation: IntegerRepresentationType(datatypeValue))
    }

    var datatypeValue: Datatype {
        return Datatype(integerRepresentation)
    }
}

// MARK: -

private class SingleTimeTargetUpdateComputer {
    private let (lifetime, token) = Lifetime.make()
    private let scheduler = QueueScheduler()

    init(initialStateIndexedTimeTargets: ProjectIdIndexedTimeTargets,
         initialStateProjectIDsByTimeTargets: ProjectIDsByTimeTargets,
         inputWriteTimeTarget: SignalProducer<TimeTarget, NoError>,
         inputDeleteTimeTarget: SignalProducer<ProjectID, NoError>,
         outputProjectIDsByTimeTargetsUpdate: BindingTarget<ProjectIDsByTimeTargets.Update.TimeTargetUpdate>) {

        indexedTimeTargets = initialStateIndexedTimeTargets
        projectIDsByTimeTargets = initialStateProjectIDsByTimeTargets

        writeTimeTarget <~ inputWriteTimeTarget
        deleteTimeTarget <~ inputDeleteTimeTarget

        lifetime += outputProjectIDsByTimeTargetsUpdate <~ projectIDsByTimeTargetsUpdatePipe.output
    }

    // MARK: - State

    private var indexedTimeTargets: ProjectIdIndexedTimeTargets
    private var projectIDsByTimeTargets: ProjectIDsByTimeTargets

    // MARK: - Input

    private lazy var writeTimeTarget = BindingTarget<TimeTarget>(on: scheduler, lifetime: lifetime) { [weak self] in
        self?.computeAndUpdate(timeTarget: $0, projectID: $0.projectId)
    }

    private lazy var deleteTimeTarget = BindingTarget<ProjectID>(on: scheduler, lifetime: lifetime) { [weak self] in
        self?.computeAndUpdate(timeTarget: nil, projectID: $0)
    }

    private func computeAndUpdate(timeTarget: TimeTarget?, projectID: ProjectID) {
        // Compute update
        guard let update = ProjectIDsByTimeTargets.Update.TimeTargetUpdate
            .forTimeTargetChange(involving: timeTarget,
                                 for: projectID,
                                 within: indexedTimeTargets,
                                 affecting: projectIDsByTimeTargets)
            // would return nil only if `projectID` were not included in `projectIDsByTimeTargets`
            else {
                return
        }

        // Update internal state
        indexedTimeTargets[projectID] = timeTarget
        projectIDsByTimeTargets = update.apply(to: projectIDsByTimeTargets)

        // Send update
        projectIDsByTimeTargetsUpdatePipe.input.send(value: update)
    }

    // MARK: - Output

    private let projectIDsByTimeTargetsUpdatePipe =
        Signal<ProjectIDsByTimeTargets.Update.TimeTargetUpdate, NoError>.pipe()
}

// MARK: -

private let timeTargetWriteScheduler = UIScheduler()
