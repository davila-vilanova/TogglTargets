//
//  TimeTargetsStore.swift
//  TogglTargets
//
//  Created by David Davila on 01.02.17.
//  Copyright Â© 2017 davi. All rights reserved.
//

import Foundation
import SQLite
import Result
import ReactiveSwift

typealias ProjectIndexedGoals = [ProjectID : TimeTarget]

/// Producer of `ProjectIDsByGoals.Update` values that when started emits a
// `full(ProjectIDsByGoals)` value which can be followed by full or
/// incremental updates.
typealias ProjectIDsByGoalsProducer = SignalProducer<ProjectIDsByGoals.Update, NoError>

/// An entity that stores and retrieves TimeTarget values
protocol TimeTargetsStore {

    /// Function which takes a project ID as input and returns a producer that
    /// emits values over time corresponding to the time target associated with that
    /// project ID.
    ///
    /// - note: `nil` target values represent a time target that does not exist yet or
    ///         that has been deleted.
    var readGoal: ReadTimeTarget { get }

    /// Target which accepts new (or edited) timeTarget values.
    var writeGoal: BindingTarget<TimeTarget> { get }

    /// Target which for each received project ID deletes the timeTarget associated with that project ID.
    var deleteGoal: BindingTarget<ProjectID> { get }
}

/// An entity that receives a stream of collections of project IDs and produces a stream of
/// `ProjectIDsByGoals` values and incremental updates generated by matching the received project IDs
/// against the goals and changes to the goals it has knowledge of.
protocol ProjectIDsByTimeTargetsProducing {
    /// Target that accepts and array of unsorted project IDs that will be matched against the goals
    /// that this store has knowledge of.
    var projectIDs: BindingTarget<[ProjectID]> { get }

    /// Producer of `ProjectIDsByGoals.Update` values that when started emits a
    // `full(ProjectIDsByGoals)` value which can be followed by full or
    /// incremental updates, corresponding to the `ProjectIDsByGoals` generated
    /// by matching project IDs provided to the `projectIDs` target against the
    /// goals this store knows about.
    var projectIDsByGoalsProducer: ProjectIDsByGoalsProducer { get }
}

protocol GoalPersistenceProvider {
    var persistGoal: BindingTarget<TimeTarget> { get }
    var deleteGoal: BindingTarget<ProjectID> { get }
    var allGoals: MutableProperty<ProjectIndexedGoals> { get }
}

class SQLiteGoalPersistenceProvider: GoalPersistenceProvider {
    /// The database connection used to store and retrieve goals.
    private let db: Connection

    // MARK: - Table and expression entities

    private let goalsTable = Table("time_goal")
    private let idExpression = Expression<Int64>("id")
    private let projectIdExpression = Expression<ProjectID>("project_id")
    private let hoursTargetExpression = Expression<Int>("hours")
    private let workWeekdaysExpression = Expression<WeekdaySelection>("work_weekdays")


    // MARK: -

    private let (lifetime, token) = Lifetime.make()
    private lazy var scheduler = QueueScheduler()

    private let _persistGoal = MutableProperty<TimeTarget?>(nil)

    /// Persists the provided time target into the database synchronously.
    var persistGoal: BindingTarget<TimeTarget> { return _persistGoal.deoptionalizedBindingTarget }

    private let _deleteGoal = MutableProperty<ProjectID?>(nil)

    /// Deletes synchronously from the database the time target corresponding to the
    /// provided project ID.
    var deleteGoal: BindingTarget<ProjectID> { return _deleteGoal.deoptionalizedBindingTarget }

    lazy var allGoals = MutableProperty<ProjectIndexedGoals>(retrieveAllGoals())

    /// Retrieves all goals from the database
    private func retrieveAllGoals() -> ProjectIndexedGoals {
        var retrievedGoals = ProjectIndexedGoals()
        let retrievedRows = try! db.prepare(goalsTable)
        for retrievedRow in retrievedRows {
            let projectIdValue = retrievedRow[projectIdExpression]
            let hoursTargetValue = retrievedRow[hoursTargetExpression]
            let workWeekdaysValue = try! /* TODO */ retrievedRow.get(workWeekdaysExpression) // [1]
            let timeTarget = TimeTarget(for: projectIdValue,
                            hoursTarget: hoursTargetValue,
                            workWeekdays: workWeekdaysValue)
            retrievedGoals[projectIdValue] = timeTarget
        }

        return retrievedGoals
        // [1] Can't use subscripts with custom types.
        // https://github.com/stephencelis/SQLite.swift/blob/master/Documentation/Index.md#custom-type-caveats
        // (f3da195)
    }

    /// Initialize an instance that will read and write its database in the provided base directory.
    /// If no database file exists under the provided directory it will create one.
    /// Returns `nil` if the database file cannot be opened and cannot be created.
    ///
    /// - parameters:
    ///   - baseDirectory: The `URL` of the directory from which to read and to which to write
    ///     the database used by this instance.
    init?(baseDirectory: URL?) {
        do {
            let databaseURL = URL(fileURLWithPath: "goalsdb.sqlite3", relativeTo: baseDirectory)
            db = try Connection(databaseURL.absoluteString)
        } catch {
            return nil
        }

        ensureSchemaCreated()

        let persistProducer = _persistGoal.producer.skipNil().on(value: { [unowned self] timeTarget in
            try! self.db.run(self.goalsTable.insert(or: .replace,
                                                    self.projectIdExpression <- timeTarget.projectId,
                                                    self.hoursTargetExpression <- timeTarget.hoursTarget,
                                                    self.workWeekdaysExpression <- timeTarget.workWeekdays))
            // TODO: synchronize periodically instead of writing immediately
        }).start(on: goalWriteScheduler)

        let deleteProducer = _deleteGoal.producer.skipNil().on(value: { [unowned self] projectId in
            let q = self.goalsTable.filter(self.projectIdExpression == projectId)
            try! self.db.run(q.delete())
        }).start(on: goalWriteScheduler)

        allGoals <~ persistProducer.withLatest(from: allGoals).map {
            $1.updatingValue($0, forKey: $0.projectId)
        }

        allGoals <~ deleteProducer.withLatest(from: allGoals).map {
            $1.updatingValue(nil, forKey: $0)
        }
    }

    /// Creates the underlying database schema if not already created.
    private func ensureSchemaCreated() {
        try! db.run(goalsTable.create(ifNotExists: true) { t in
            t.column(idExpression, primaryKey: .autoincrement)
            t.column(projectIdExpression, unique: true)
            t.column(hoursTargetExpression)
            t.column(workWeekdaysExpression)
        })
    }

    private func deleteGoal(for projectId: ProjectID) {
        let q = goalsTable.filter(projectIdExpression == projectId)
        try! db.run(q.delete())
    }
}


// MARK: -

/// Represents an entity that conforms to both the `TimeTargetsStore` and `ProjectIDsByTimeTargetsProducing` protocols.
protocol ProjectIDsProducingTimeTargetsStore: TimeTargetsStore, ProjectIDsByTimeTargetsProducing { }


// MARK: -

class ConcreteProjectIDsProducingTimeTargetsStore: ProjectIDsProducingTimeTargetsStore {

    private let (lifetime, token) = Lifetime.make()

    private let persistenceProvider: GoalPersistenceProvider
    private let undoManager: UndoManager

    init(persistenceProvider: GoalPersistenceProvider, undoManager: UndoManager) {
        self.persistenceProvider = persistenceProvider
        self.undoManager = undoManager

        let writeGoalProducer = _writeGoal.producer.skipNil()
        let deleteGoalProducer = _deleteGoal.producer.skipNil()

        let undoModifyOrDeleteGoal = BindingTarget<TimeTarget>(on: goalWriteScheduler, lifetime: lifetime) { [unowned _writeGoal] goalBeforeEditing in
            undoManager.registerUndo(withTarget: _writeGoal) {
                $0 <~ SignalProducer(value: goalBeforeEditing).start(on: UIScheduler())
            }
        }
        let undoCreateGoal = BindingTarget<ProjectID>(on: goalWriteScheduler, lifetime: lifetime) { [unowned _deleteGoal] projectId in
            undoManager.registerUndo(withTarget: _deleteGoal, handler: { $0 <~ SignalProducer(value: projectId).start(on: UIScheduler()) })
        }
        let goalsPreModification = writeGoalProducer.map { $0.projectId }.withLatest(from: persistenceProvider.allGoals).map { $0.1[$0.0] }.skipNil()
        let goalsPreDeletion = deleteGoalProducer.withLatest(from: persistenceProvider.allGoals).map { $0.1[$0.0] }.skipNil()

        undoModifyOrDeleteGoal <~ SignalProducer.merge(goalsPreModification, goalsPreDeletion)

        let idsOfCreatedGoals = writeGoalProducer.map { $0.projectId }.withLatest(from: persistenceProvider.allGoals).map { ($0.1[$0.0], $0.0) }.filter { $0.0 == nil }.map { $0.1 }

        undoCreateGoal <~ idsOfCreatedGoals

        let singleGoalUpdateComputer = Property<SingleGoalUpdateComputer?>(
            initial: nil,
            then: projectIDsByGoalsFullRefresh.withLatest(from: persistenceProvider.allGoals)
                .map { [unowned self] (projectIDsByGoalsState, indexedGoalsState) in
                    SingleGoalUpdateComputer(initialStateIndexedGoals: indexedGoalsState,
                                             initialStateProjectIDsByGoals: projectIDsByGoalsState,
                                             inputWriteGoal: writeGoalProducer,
                                             inputDeleteGoal: deleteGoalProducer,
                                             outputProjectIDsByGoalsUpdate: self.projectIDsByGoalsLastSingleUpdate.deoptionalizedBindingTarget)
            }
        )

        lifetime.observeEnded {
            _ = singleGoalUpdateComputer
        }

        persistenceProvider.persistGoal <~ writeGoalProducer
        persistenceProvider.deleteGoal <~ deleteGoalProducer
    }


    // MARK: - TimeTarget interface

    /// Function which takes a project ID as input and returns a producer that
    /// emits values over time corresponding to the time target associated with that
    /// project ID.
    ///
    /// - note: `nil` target values represent a time target that does not exist yet or
    ///         that has been deleted.
    lazy var readGoal: ReadTimeTarget = { projectID in
        self.persistenceProvider.allGoals.producer.map { $0[projectID] }.skipRepeats { $0 == $1 }
    }

    var writeGoal: BindingTarget<TimeTarget> { return _writeGoal.deoptionalizedBindingTarget }
    private let _writeGoal = MutableProperty<TimeTarget?>(nil)

    var deleteGoal: BindingTarget<ProjectID> { return _deleteGoal.deoptionalizedBindingTarget }
    private let _deleteGoal = MutableProperty<ProjectID?>(nil)


    // MARK: - Generation of ProjectIDsByGoals

    /// Target that accepts an array of unsorted project IDs that will be matched against the goals
    /// that this store has knowledge of.
    var projectIDs: BindingTarget<[ProjectID]> { return _projectIDs.deoptionalizedBindingTarget }

    /// The value backer for the `projectIDs` target.
    private var _projectIDs = MutableProperty<[ProjectID]?>(nil)

    /// Produces a new `ProjectIDsByGoals` value each time a value is sent to the `projectIDs` target
    /// that contains a different set of unique IDs than the last seen one.
    private lazy var projectIDsByGoalsFullRefresh: SignalProducer<ProjectIDsByGoals, NoError> =
        _projectIDs.producer.skipNil().withLatest(from: persistenceProvider.allGoals)
            .skipRepeats { (old, new) -> Bool in // let through only changes in project IDs, order insensitive
                let oldIds = Set(old.0)
                let newIds = Set(new.0)
                return oldIds == newIds
            }
            .map(ProjectIDsByGoals.init)

    /// Used to connect the output of the current `SingleGoalUpdateComputer`
    /// to `projectIDsByGoalsProducer`.
    private let projectIDsByGoalsLastSingleUpdate = MutableProperty<ProjectIDsByGoals.Update.GoalUpdate?>(nil)


    /// Producer of `ProjectIDsByGoals.Update` values that when started emits a
    // `full(ProjectIDsByGoals)` value which can be followed by by full or
    /// incremental updates, corresponding to the `ProjectIDsByGoals` generated
    /// by matching project IDs provided to the `projectIDs` target against the
    /// goals this store knows about.
    lazy var projectIDsByGoalsProducer: ProjectIDsByGoalsProducer =
        SignalProducer.merge(
            // Send a full value and any full value updates that happen from now on
            projectIDsByGoalsFullRefresh.map (ProjectIDsByGoals.Update.full),
            // Send any updates to a single time target that happen from now on
            projectIDsByGoalsLastSingleUpdate.producer.skipNil().map (ProjectIDsByGoals.Update.singleGoal)
    )
}

extension WeekdaySelection: Value {
    typealias Datatype = Int64

    static var declaredDatatype: String {
        get {
            return Int64.declaredDatatype
        }
    }

    static func fromDatatypeValue(_ datatypeValue: Datatype) -> WeekdaySelection {
        return WeekdaySelection(integerRepresentation: IntegerRepresentationType(datatypeValue))
    }

    var datatypeValue: Datatype {
        get {
            return Datatype(integerRepresentation)
        }
    }
}

// MARK : -

fileprivate class SingleGoalUpdateComputer {
    private let (lifetime, token) = Lifetime.make()
    private let scheduler = QueueScheduler()

    init(initialStateIndexedGoals: ProjectIndexedGoals,
         initialStateProjectIDsByGoals: ProjectIDsByGoals,
         inputWriteGoal: SignalProducer<TimeTarget, NoError>,
         inputDeleteGoal: SignalProducer<ProjectID, NoError>,
         outputProjectIDsByGoalsUpdate: BindingTarget<ProjectIDsByGoals.Update.GoalUpdate>) {

        indexedGoals = initialStateIndexedGoals
        projectIDsByGoals = initialStateProjectIDsByGoals

        writeGoal <~ inputWriteGoal
        deleteGoal <~ inputDeleteGoal

        lifetime += outputProjectIDsByGoalsUpdate <~ projectIDsByGoalsUpdatePipe.output
    }

    // MARK: - State

    private var indexedGoals: ProjectIndexedGoals
    private var projectIDsByGoals: ProjectIDsByGoals

    // MARK: - Input

    private lazy var writeGoal = BindingTarget<TimeTarget>(on: scheduler, lifetime: lifetime) { [weak self] in
        self?.computeAndUpdate(newGoal: $0, projectID: $0.projectId)
    }

    private lazy var deleteGoal = BindingTarget<ProjectID>(on: scheduler, lifetime: lifetime) { [weak self] in
        self?.computeAndUpdate(newGoal: nil, projectID: $0)
    }

    private func computeAndUpdate(newGoal: TimeTarget?, projectID: ProjectID) {
        // Compute update
//        assert(projectIDsByGoals.sortedProjectIDs.contains(projectID), "projectID must be included in projectIDsByGoals")
        guard let update = ProjectIDsByGoals.Update.GoalUpdate
            .forGoalChange(involving: newGoal,
                           for: projectID,
                           within: indexedGoals,
                           affecting: projectIDsByGoals) // would return nil only if `projectID` were not included in `projectIDsByGoals`
            else {
                return
        }

        // Update internal state
        indexedGoals[projectID] = newGoal
        projectIDsByGoals = update.apply(to: projectIDsByGoals)

        // Send update
        projectIDsByGoalsUpdatePipe.input.send(value: update)
    }

    // MARK: - Output

    private let projectIDsByGoalsUpdatePipe = Signal<ProjectIDsByGoals.Update.GoalUpdate, NoError>.pipe()
}

// MARK: -

fileprivate let goalWriteScheduler = UIScheduler()
